import { LinkedList } from "./dataStructures/LinkedList.js";
import { PriorityQueue } from "./dataStructures/PriorityQueue.js";


export let ALL_TIME_SOLIDS = new LinkedList();
export let LINKED_LIST_POINTER;

export let COLLISION_SOON_SOLIDS = new PriorityQueue([], (a, b) => { return a.t1 < b.t1; }); // do we even need this?
export let COLLISION_RELEVANT_SOLIDS = new PriorityQueue([], (a, b) => { return a.t2 < b.t2; });

/**
  0. Load all relavant TimeSolids to the COLLISION_RELEVANT_SOLIDS (Maybe change the ALL_TIME_SOLIDS to a cross-linked list, which would sort the elments with respect to start and end times). All relevant TimeSolids are all those who have not finished by the start time of your catch-up sweep.
  1. run through TimeSolids until you reach a) the end or b) the current time
    For each TimeSolid:
      a. find any collisions with TimeSolids in RELEVANT_SOLIDS queue
        i.  check for locality -> get line for each, see if it ever gets near enough to concern
          line begins at the 2D spacial point of first time of common existance, end at last time of common existance..... or check the distance of the vector from one lime to the other in 3d space (the cross product of the two lines) for sufficient locality... idk how to find the closest point on each line though. We could also test various levels of locality.. making a general box first..
        ii. check for collision (except on the top faces? - be sure to make that new solids dont cross though!!!!!!!)
          For each Collision:
            A) Cut the TimeSolids, adding the new solids to the linked List (for efficiency, add an option to have a "first guess".. or just add it at the current time? would the LINKED_LIST_POINTER be pointing to the right time? almost.. it would be after the block of blocks that start at that time.. but very close)
              I - New solids are generated by applying a rule to the entity and then questing a new timeSolid - sort of a call and response. (does this method handle the infinite race well? No. How can we fix that??)
    After each TimeSolid, when we increment the timePointer thing (which points to the time we are processing) and rid the relevant solids of any solids that ended before the next time


  A thought on efficiency:
    if these calculations prove to be too much, perhaps it would be easier to have groups of relevant solids for each section of the board, and deal with duplicates when time paralelpipeds cross into different parts of the board.
    
  **/
export class Point { // also may also be thought of as a Vector
  // generally, every method without "get-" modifies and then returns the orignial object.
  /**
   * @param {number} x
   * @param {number} y
   * @param {number} z the time coordinate of this point, in milliseconds, relative to GAME_START
   */
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  toString() {
    return "(" + this.x + ", " + this.y + ", " + this.z + ")";
  }
  clone() {
    return new Point(this.x, this.y, this.z); // does this need to have "new"?
  }


  add(point) {
    this.x += point.x;
    this.y += point.y;
    this.z += point.z;
    return this;
  }
  sub(point) {
    this.x -= point.x;
    this.y -= point.y;
    this.z -= point.z;
    return this;
  }
  getDot(vector) {
    const resX = this.x * vector.x;
    const resY = this.y * vector.y;
    const resZ = this.z * vector.z;
    return resX + resY + resZ;
  }
  cross(vector) {
    const newX = this.y * vector.z - this.z * vector.y;
    const newY = this.x * vector.z - this.z * vector.x;
    const newZ = this.x * vector.y - this.y * vector.x;
    this.x = newX;
    this.y = newY;
    this.z = newZ;
    return this;
  }
  scalarMultiply(c) {
    this.x *= c;
    this.y *= c;
    this.z *= c;
    return this;
  }
  getProjOnto(vector) {
    let v = vector.clone().normalize();
    return v.scalarMultiply(this.getDot(v));
  }
  getNorm() {
    this.norm = this.norm || Math.sqrt(this.getDot(this));
    return this.norm;
  }
  getNorm2() {
    this.norm2 = this.norm2 || this.getDot(this);
    return this.norm2;
  }
  normalize() {
    this.x /= this.getNorm();
    this.y /= this.norm;
    this.z /= this.norm;
    return this;
  }
  getDeterminant(point2, point3) {
    let l1 = this;
    let l2 = point2;
    let l3 = point3;
    return l1.x * l2.y * l3.z
      + l2.x * l3.z * l1.z
      + l3.x * l1.z * l2.z
      - l3.x * l2.y * l1.z
      - l2.x * l1.y * l3.z
      - l1.x * l3.y * l2.z;
  }
  abs(){
    if (this.x < 0) this.x *= -1;
    if (this.y < 0) this.y *= -1;
    if (this.z < 0) this.z *= -1;
    return this;
  }
  doSanityCheck(){
    // throw an error if any variable is undefined or null
    if (isNaN(this.x) || this.x == null ||
        isNaN(this.y) || this.y == null ||
        isNaN(this.z) || this.z == null ){
          console.log(this);
          throw new Error("Point/vector has variable with bad value");
        }
  }
  equals(point){
    return this.x == point.x && this.y == point.y && this.z == point.z;
  }
  isScaledEquals(point){
    const a = this.x/point.x;
    if (isNaN(a)){
      a = point.x / this.x;
      const b = point.y / this.y;
      const c = point.z / this.z;
      return a == b && b == c;
    }
    const b = this.y/point.y;
    const c = this.z/point.z;
    return a == b && b == c;
  }

}
class Line {
  /**
   * @param {Point} p1
   * @param {Point} p2
   */
  constructor(p1, p2) {
    this.point1 = p1.clone();
    this.point2 = p2.clone();
    this.vector = p2.clone().sub(p1);
  }
  toString() {
    return this.point1.toString() + " ----- " + this.point2.toString();
  }

  /**
   * @returns {Point}   vector representing the path from p1 to p2
   */
  getVector() {
    return this.vector;
  }

  // /**
  //  * @param {Face} plane   face whose plane you want to find the intersection with this line
  //  */
  // getIntersection(plane) { // important note: this does not check to see if it intersects the face.

  //   // note to self: dont flip them here becasue then the vector would be wrong
  //   if (this.point1.z > this.point2.z) throw new Error("BROKEN ASSUMPTIONS: this line is not in order of older point to newer point.");

  //   if (plane.getPlaneOffset(this.point1) > 0 && plane.getPlaneOffset(this.point2) <= 0) { // if 1st is outside, and 2nd is inside/on
  //     // number of vectors added to point1 that it takes to get to the intersection
  //     const s = (plane.equC - plane.asPlane().getDot(this.point1)) / plane.asPlane().getDot(this.vector);

  //     return this.point1.z + s * this.vector.z;
  //   } else {
  //     return null; // there can be no intersection worth recording
  //   }
  // }
  getIntersection(line, axis) { // important note: this does not check to see if it intersects the face.
    //we assume theyre not colinaer
    if (axis = 'x') this.crosses(line).x;
    if (axis = 'y') this.crosses(line).y;
    if (axis = 'z') this.crosses(line).z;
  }
  isColinear(line){
    const c = line.vector.x / this.vector.x;
    return (this.vector.y * c == line.vector.y && this.vector.z * c == line.vector.z);
  }
  crosses(line){
    if (this.isColinear(line)) return line.point1; // colinear lines

    const [a, d] = [this.point1.x - line.point1.x, this.point2.y - line.point2.y];
    const [b, e] = [-this.vector.x, -this.vector.y];
    const [c, f] = [ line.vector.x,  line.vector.y];

    const s = c*e - f*b
    if (s === 0) { // parallel lines in the x and y dimensions
      const [a, d] = [this.point1.x - line.point1.x, this.point2.z - line.point2.z];
      const [b, e] = [-this.vector.x, -this.vector.z];
      const [c, f] = [ line.vector.x,  line.vector.z];

      const s = c*e - f*b
      if (s === 0) return false; // truely parallel lines

      let c1 = (a*e - d*b) / (s);
      let c2 = (d*c - a*f) / (s);

      const collisionPoint = this.vector.clone().scalarMultiply(c1).add(this.point1);
      if (collisionPoint === line.vector.clone().scalarMultiply(c2).add(line.point1)) return collisionPoint;
      return false;
    } // parallel lines
    let c1 = (a*e - d*b) / (s);
    let c2 = (d*c - a*f) / (s);

    const collisionPoint = this.vector.clone().scalarMultiply(c1).add(this.point1);
    if (collisionPoint === line.vector.clone().scalarMultiply(c2).add(line.point1)) return collisionPoint;
    return false;
  }
  intersectsFace(face){
    // are the points on different sides of the plane? OR do they both lie in the plane?
    const c1 = face.getPlaneOffset(this.point1);
    const c2 = face.getPlaneOffset(this.point2);
    if (c1 === 0 || c2 === 0){
      if (face.contains(this.point1)) return this.point1;
      if (face.contains(this.point2)) return this.point2;
      if (c1 === 0 && c2 === 0){
        for (const nextLine of face.asLines()){
          const crossing = this.crosses(nextLine);
          if (crossing != false) return crossing;
        }
      }
      return false;
    } else if (c1 > 0 ^ c2 > 0) {
      goalP = this.point1.clone().add(this.vector.scalarMultiply(c1/(c1-c2)));
      return face.contains(goalP, false);
    }
  }
  determinant(line2, line3) {
    let l1 = this.vector;
    let l2 = line2.vector;
    let l3 = line3.vector;
    return l1.x * l2.y * l3.z
      + l2.x * l3.z * l1.z
      + l3.x * l1.z * l2.z
      - l3.x * l2.y * l1.z
      - l2.x * l1.y * l3.z
      - l1.x * l3.y * l2.z;
  }
  getOffsetToLine(otherLine) {
    /**
     *  We treat the problem as a system
     * [l1 l2 l1xl2][scalars] = p1-p2 (any two points on the lines)
     *  We want the last scalar times the l1xl2 vector
     */
    
    let l1 = this.vector;
    let l2 = otherLine.vector;
    let l3 = l1.clone().cross(l2);

    let v = this.point1.clone().sub(otherLine.point1);

    // using cramer's rule
    let thirdScalar = v.getDeterminant(l1, l2) / l3.getDeterminant(l1, l2);

    return l3.scalarMultiply(thirdScalar);
  }
  doSanityCheck(){
    // throw an error if any variable is undefined or null
    if (this.point1 == null ||
        this.point1 == null ||
        this.vector == null ){
          console.log(this);
          throw new Error("Line has variable with bad value");
        }
    this.point1.doSanityCheck();
    this.point1.doSanityCheck();
    this.vector.doSanityCheck();
  }
}
class Face {
  constructor(p0, p1, p2, p3) {
    /**
     *   p2 --- p3
     *    |     |
     *   p0 --- p1
    */
    // if (p0.z === -1) throw new Error("WHAH");
    this.p0 = p0.clone();
    this.p1 = p1.clone();
    this.p2 = p2.clone();
    this.p3 = p3.clone();

    // I forgot about the getPlane() function...
    //
    // let normVectCandidates = [
    //   this.getNormalVector(new Point(...[1, 0, 0])),
    //   this.getNormalVector(new Point(...[0, 1, 0])),
    //   this.getNormalVector(new Point(...[0, 0, 1]))
    // ]
    // this.normalVector = null;
    // for (candidate of normVectCandidates){
    //   if (candidate.getNorm() > 0.0001) {
    //     this.normalVector = candidate.normalize();
    //     break;
    //   }
    // }
    // if (this.normalVector === null) throw error("Face is not a plane");

    this.lines;
  }
  getNormalVector(startingVector){ // graham schmit process
    let vector = startingVector;
    vector.sub(vector.getProjOnto(this.p0));
    vector.sub(vector.getProjOnto(this.p1));
    vector.sub(vector.getProjOnto(this.p2));
    vector.sub(vector.getProjOnto(this.p3));
    return vector;
  }
  toString() {
    return "Face:\n" +
      "\t" + this.p0.toString() + ",\n" +
      "\t" + this.p1.toString() + ",\n" +
      "\t" + this.p2.toString() + ",\n" +
      "\t" + this.p3.toString() + "\n";
  }
  asLines() { // generator that yields the bottom, top then sides of the face.
    if (!this.lines){
      this.lines = [
        new Line(this.p0, this.p1),
        new Line(this.p1, this.p3),
        new Line(this.p3, this.p2),
        new Line(this.p2, this.p0) // keeping them in the right order is important
      ]; // TODO, wanted this to be yields
    }
    return this.lines;
  }
  getPlane() { // meaning return the vector perp to that plane, according to the right hand rule, pointing out of the figure above
    this.equ = this.equ || this.p1.clone().sub(this.p0).cross(this.p2.clone().sub(this.p0));
    return this.equ;
  }
  // intersects is for planes
  // crosses is for lines
  // contains is for points
  intersects(face){ // asumes p0 is the first point in time, and that the faces only instersect at one point in time (unless they are touching sides)
    // for (let line of face.asLines()){
    //   const crossing = this.crosses(line);
    //   if (crossing != false) return crossing;
    // }
    // for (let line of this.asLines()){
    //   const crossing = face.crosses(line);
    //   if (crossing != false) return crossing;
    // }
    const pln1 = this.getPlane();
    const pln2 = face.getPlane();
    
    if (pln1 == pln2) return false;
    const vect = pln1.copy().cross(pln2); // we now have the direction of the plane, now we need a starting point

    const c1 = this.getEquC();
    const c2 = face.getEquC();

    // solve the system of equations
    let det = pln1.y * pln2.x - pln2.y  * pln1.x;
    let pnt;
    if (det == 0){ // then we'll try with something other than the z value being 0 -> the next det shouldnt be zero bc that would mean the lines are colinear
      det = pln1.z * pln2.x - pln2.z  * pln1.x;
      const x = (pln1.z * c2 - pln2.z  * c1) / det;
      const z = (pln2.x * c1 - pln1.x  * c2) / det;
      pnt = Point(x, 0, z);
    } else { // with the z value being 0
      const x = (pln1.y * c2 - pln2.y  * c1) / det;
      const y = (pln2.x * c1 - pln1.x  * c2) / det;
      pnt = Point(x, y, 0);
    }
    return Line(pnt, vect.add(pnt));
  }
  // crosses(line){
  //   // are the points on different sides of the plane? OR do they both lie in the plane?
  //   // console.log(line);
  //   const c1 = this.getPlaneOffset(line.point1);
  //   const c2 = this.getPlaneOffset(line.point2);
  //   if (c1 === 0 || c2 === 0){
  //     if (this.contains(line.point1)) return line.point1;
  //     if (this.contains(line.point2)) return line.point2;
  //     if (c1 === 0 && c2 === 0){
  //       for (const nextLine of this.asLines()){
  //         const crossing = nextLine.crosses(line);
  //         if (crossing != false) return crossing;
  //       }
  //     }
  //     return false;
  //   } else if (c1 > 0 ^ c2 > 0) {
  //     let goalP = line.point1.clone().add(line.vector.scalarMultiply(c1/(c1-c2)));
  //     return this.contains(goalP, false);
  //   }
  //   return false;
  // }
  // contains(point, checkIfOnPlane = true){
  //   if (checkIfOnPlane && this.getPlaneOffset(point) !== 0) return false;

  //   let firstC = 0;
  //   for (const nextLine of this.asLines()){ // check to make sure no points are on different sides of the line
      
  //     const newPlane = new Face(nextLine.point1, nextLine.point2, 
  //       nextLine.point1.clone().add(this.getPlane()),
  //       nextLine.point1.clone().add(this.getPlane()));
  //     let c = newPlane.getPlaneOffset(point);
  //     if (firstC != 0 && c != 0){
  //       if (c > 0 ^ firstC > 0) return false;
  //     } else if (c != 0) firstC = c;
  //   }
  //   return point;
  // }
  /**
   * @param {Point} point
   * @returns {Number}   basically represents how far off the point is from the plane (+ if in the same direction as the plane)
   */
  getEquC(){
    this.equC = this.equC || this.getPlane().getDot(this.p0); // the constant in the equation to the plane
    return this.equC;
  }
  getPlaneOffset(point) {
    // console.log(point);
    this.doSanityCheck();
    return this.getPlane().getDot(point) - this.getEquC();
  }
  doSanityCheck(){
    // throw an error if any variable is undefined or null
    // if (isNaN(this.x)  || this.x  == null ||
    //     isNaN(this.y)  || this.y  == null ||
    //     isNaN(this.r1) || this.r1 == null ||
    //     isNaN(this.r2) || this.r2 == null ||
    //     isNaN(this.t1) || this.t1 == null ||
    //     isNaN(this.t2) || this.t2 == null ||
    //     this.center == null ||
    //     this.line   == null ||
    //     this.vector == null ){
    //       console.log(this);
    //       throw new Error("TimeSolid has variable with bad value");
    //     }
    // this.center.doSanityCheck();
    // this.line.doSanityCheck();
    // this.vector.doSanityCheck();
    if (this.p0 == null ||
        this.p1 == null ||
        this.p2 == null ||
        this.p3 == null){
          console.log(this);
          throw new Error("TimeSolid has variable with bad value");
    }
      this.p0.doSanityCheck();
      this.p1.doSanityCheck();
      this.p2.doSanityCheck();
      this.p3.doSanityCheck();
  }

}
class TimeSolid {
  /**
   * @param {String} type   name of class being instantiated
   * @param {Number} x      coordinate of the center of the shape at time t1
   * @param {Number} y      coordinate of the center of the shape at time t1
   * @param {Number} r1     radius of the base along the x-axis
   * @param {Number} r2     radius of the base along the y-axis
   * @param {Number} t1     time in millisecods from the start of the game at which this time solid begins
   * @param {Number} t2     time in millisecods from the start of the game at which this time solid ends
   * @param {Point}  vector vector of movement of this shape through time: (dx, dy, dt).
   */
  constructor(type, x, y, r1, r2, t1, t2, vector) {
    this.type = type; // do i need to copy this? prob not

    // x and y coordinates represent the center of the object
    this.x = x;
    this.y = y;

    this.r1 = r1;
    this.r2 = r2;

    this.t1 = t1;
    this.t2 = t2;

    this.center = new Point(x, y, t1);
    this.line = new Line(this.center, this.center.clone().add(vector));
    this.vector = vector.clone();
  }
  getFaces() {
    throw new Error("getFaces has not been initialized correctly");
  }
  getIntersection(timeSolid) {
    throw new Error("getIntersection has not been initialized correctly");
  }
  doSanityCheck(){
    // throw an error if any variable is undefined or null
    if (isNaN(this.x)  || this.x  == null ||
        isNaN(this.y)  || this.y  == null ||
        isNaN(this.r1) || this.r1 == null ||
        isNaN(this.r2) || this.r2 == null ||
        isNaN(this.t1) || this.t1 == null ||
        isNaN(this.t2) || this.t2 == null ||
        this.center == null ||
        this.line == null ||
        this.vector == null){
          console.log(this);
          throw new Error("Face has variable with bad value");
    }
    this.center.doSanityCheck();
    this.line.doSanityCheck();
    this.vector.doSanityCheck();
  }
}
export class TimeParallelepiped extends TimeSolid {

  /**  point indicies (c marks the x,y,t1 center)
     *    6-----7                           6-----7
     *    |\    |\                >        / \   / \ 
     *    | 4---+-5               >       /   4-----5
     *    2-+---3 |      t        >      2---/-3   /     t  vector
     *     \| c  \|    y |        >       \ /c  \ /    y | /
     *      0-----1     \|__x              0-----1      \|/_x
     */
  pointsInFaces = [ // constructed with the faces pointing out of the shape (right hand rule of [0]->[1] and [0]->[2]). 
    // last point is always all the way across the shape from the first

    [0, 2, 1, 3], // bottom face
    [4, 5, 6, 7], // top face
    [0, 1, 4, 5], // "front" p0 face
    [3, 2, 7, 6], // "back" p3 face
    [1, 3, 5, 7], // "right-side" p1 face
    [2, 0, 6, 4]  // "left-side" p2 face      
  ];

  /**
   * @param {Number} x      the coordinate of the center of the shape at time t1
   * @param {Number} y      the coordinate of the center of the shape at time t1
   * @param {Number} w      the width of the base at t1 in the x-axis
   * @param {Number} l      the legnth of the base at t1 in the y-axis
   * @param {Number} t1     the time in millisecods from the start of the game at which this time solid begins
   * @param {Number} t2     the time in millisecods from the start of the game at which this time solid ends
   * @param {Point}  vector the vector of movement of this shape through time: (dx, dy, dt).
   */
  constructor(x, y, w, l, t1, t2, vector) {
    // x and y coordinates represent the center of the object
    super("parallelepiped", x, y, w / 2, l / 2, t1, t2, vector = new Point(0,0, t2 - t1));

    /**  point indicies (c marks the x,y,t1 center)
     *    6-----7                           6-----7
     *    |\    |\                >        / \   / \ 
     *    | 4---+-5               >       /   4-----5
     *    2-+---3 |      t        >      2---/-3   /     t  vector
     *     \| c  \|    y |        >       \ /c  \ /    y | /
     *      0-----1     \|__x              0-----1      \|/_x
     */
    
    vector.doSanityCheck();
    if (vector.z === 0) {
      // console.log("ERROR: parallelpiped with time width zero");
      vector.z = 1;
    }
    this.dx = vector.x / vector.z;
    this.dy = vector.y / vector.z;
    this.dt = t2 - t1;

    this.points = [
      new Point(this.x - this.r1, this.y - this.r1, t1),
      new Point(this.x + this.r1, this.y - this.r1, t1),
      new Point(this.x - this.r1, this.y + this.r1, t1),
      new Point(this.x + this.r1, this.y + this.r1, t1),
      new Point(this.x - this.r1 + this.dx, this.y - this.r1 + this.dy, t2),
      new Point(this.x + this.r1 + this.dx, this.y - this.r1 + this.dy, t2),
      new Point(this.x - this.r1 + this.dx, this.y + this.r1 + this.dy, t2),
      new Point(this.x + this.r1 + this.dx, this.y + this.r1 + this.dy, t2),

      

    ]
    this.faces = [null, null, null, null, null, null];
    this.getFaces();
  }
  getFaces() {
    if (this.faces[0] == null){
      // let rtrn = [];
      for (let i = 0; i < 6; i++) {
        const pnts = this.pointsInFaces[i];
        // console.log(pnts);
        this.faces[i] = new Face(this.points[pnts[0]], this.points[pnts[1]], this.points[pnts[2]], this.points[pnts[3]]);

        // rtrn.push(this.faces[i]); // TODO, wanted this to be yields
      }
    }
    return this.faces;
  }
  utility_getMiddle2of4(arr){
    const mn = arr.min();
    let hasRemovedMin = false;
    const mx = arr.max();
    let hasRemovedMax = false;
    return arr.filter((e) => {
      if (!hasRemovedMin && e === mn){
        hasRemovedMin = True;
        return false;
      } else if (!hasRemovedMax && e === mx){
        hasRemovedMax = True;
        return false;
      }
      return true;
    });
  }
  utility_getMinOfOverlapPlanesAndLine(fc1, fc2, line, axis){
    let lineSegTs1 = fc1.asLines().map((l) => {line.getIntersection(l, axis)});
    lineSegTs1 = utility_getMiddle2of4(lineSegTs1);
    let lineSegTs2 = fc2.asLines().map((l) => {line.getIntersection(l, axis)});
    lineSegTs2 = utility_getMiddle2of4(lineSegTs2);

    arr = lineSegTs1.concat(lineSegTs2);
    if (arr.min() === arr.max()) return arr[0]; // whole array values are the same
    arrOfSortedIndicies = Array.from(Array(arr.length).keys()).sort((a,b) => arr[a]-arr[b])
    arr2.map((a) => a < 2); 
    // this array is now the order of elements from the original array, but as a bool that represesnts if theyre from the first lineSetTs1;
    // [3,8,100,2] => [F,T,T,F]
    // [4,5,6,2] => [F,T,T,F]

    if ( arr2[0] ==  arr2[1]) return false; // first two bounds are from first shape or seconds shape (ie they dont overlap)
    else return arr[arrOfSortedIndicies[1]]; // return the second to least value
  }
  getIntersection(timeSolid) {
    this.doSanityCheck();
    timeSolid.doSanityCheck();

    // catch a lazy case of neither solid moving
    // if (this.dx === 0 && this.dy === 0 && 
    //   timeSolid.dx === 0 && timeSolid.dy === 0) {
        
    //     return null;
    //   }

    console.log("checking intersection with math");
    switch (timeSolid.type){ // because they can only touch once, locating one intersection is good enough to return
      case "parallelepiped":
        // ADD BACK IN !!!!
        // // are they even in the same neighborhood??
        const distFromBase = this.center.clone().sub(timeSolid.center);
        // console.log(distFromBase);
        const widthOffset = new Point(this.r1 + timeSolid.r1, this.r2 + timeSolid.r2, 0);
        // console.log(widthOffset);
        // console.log(widthOffset);
        widthOffset.doSanityCheck();
        distFromBase.abs().sub(widthOffset);
        
        // at this point if distFromBase < 0 then they are intersecting! optimize
        if (distFromBase.x <= 0 && distFromBase.y <= 0) console.log("trivial intersection!");

        const maxTravel = this.vector.clone().sub(timeSolid.vector.clone()).abs();
        distFromBase.sub(maxTravel);
        
        if (distFromBase.x <= 0 && distFromBase.y <= 0) console.log("trivially not not intersecting!");
        else return null;

        // // are the centers of the lines (extending infinetly in both directions, sufficiently close?)
          // const trueOffset = this.line.getOffsetToLine(timeSolid.line).sub(widthOffset);
          // if (trueOffset.x > 0 || trueOffset.y > 0) return null;

        // do they overlap?
        let minT = null; // wintergreen     lol... its minty.. get it? minT?
        for (const thisFace of this.getFaces().slice(2)){ // only iterate through sides of faces
          thisFace.doSanityCheck();
          for (const thatFace of timeSolid.getFaces().slice(2)){ // only iterate through sides of faces
            thatFace.doSanityCheck();
            const crossing = thisFace.intersects(thatFace);
            if (crossing == false) continue; // if the planes are parallel
            let suggestionT;
            if (crossing.vector.z == 0){ // if the line is paralell to the ground
              suggestionT = crossing.point1.z;
              if (crossing.vector.x == 0){ // if line is paralell to the x-axis too.. good gravy! so do it w/ repect to the y
                const r = utility_getMinOfOverlapPlanesAndLine(thisFace, thatFace, crossing, 'y');
                if (r == false) continue;
              } else{
                const r = utility_getMinOfOverlapPlanesAndLine(thisFace, thatFace, crossing, 'x');
                if (r == false) continue;
              }
              // !!!! catch special case where all Ts are the same and T doesnt lie on the plane intersection :(
            } else {
              suggestionT = utility_getMinOfOverlapPlanesAndLine(thisFace, thatFace, crossing, 'z');
              if (suggestionT == false) continue;
            }
            if (minT == null || suggestionT < minT) minT = suggestionT;
          }
        }

        return minT;
      case "cylinder":
        return null;
    }
  }
}
export class TimeCylinder extends TimeSolid { // technically it would be a TimeObliqueEllipticCylinder, but... yeah..
  /**
   * @param {Number} x the coordinate of the center of the shape at time t1
   * @param {Number} y the coordinate of the center of the shape at time t1
   * @param {Number} ------------------FIX
   * @param {Number} ------------------FIX
   * @param {Number} t1 the time in millisecods from the start of the game at which this time solid begins
   * @param {Number} t2 the time in millisecods from the start of the game at which this time solid ends
   * @param {Point} vector the vector of movement of this shape through time: (dx, dy, dt).
   */
  constructor(x, y, r1, r2, t1, t2, vector) {
    super("cylinder", x, y, r1, r2, t1, t2, vector);
  }
  getFaces() {
    // idk how to implement this yet
  }
}

function rejoice() {
  console.log("YES!! :)");
}