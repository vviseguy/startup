import { LinkedList } from "./dataStructures/LinkedList.js";
import { PriorityQueue } from "./dataStructures/PriorityQueue.js";


export let ALL_TIME_SOLIDS = new LinkedList();
export let LINKED_LIST_POINTER;

export let COLLISION_SOON_SOLIDS = new PriorityQueue([], (a, b) => { return a.t1 < b.t1; }); // do we even need this?
export let COLLISION_RELEVANT_SOLIDS = new PriorityQueue([], (a, b) => { return a.t2 < b.t2; });

/**
  0. Load all relavant TimeSolids to the COLLISION_RELEVANT_SOLIDS (Maybe change the ALL_TIME_SOLIDS to a cross-linked list, which would sort the elments with respect to start and end times). All relevant TimeSolids are all those who have not finished by the start time of your catch-up sweep.
  1. run through TimeSolids until you reach a) the end or b) the current time
    For each TimeSolid:
      a. find any collisions with TimeSolids in RELEVANT_SOLIDS queue
        i.  check for locality -> get line for each, see if it ever gets near enough to concern
          line begins at the 2D spacial point of first time of common existance, end at last time of common existance..... or check the distance of the vector from one lime to the other in 3d space (the cross product of the two lines) for sufficient locality... idk how to find the closest point on each line though. We could also test various levels of locality.. making a general box first..
        ii. check for collision (except on the top faces? - be sure to make that new solids dont cross though!!!!!!!)
          For each Collision:
            A) Cut the TimeSolids, adding the new solids to the linked List (for efficiency, add an option to have a "first guess".. or just add it at the current time? would the LINKED_LIST_POINTER be pointing to the right time? almost.. it would be after the block of blocks that start at that time.. but very close)
              I - New solids are generated by applying a rule to the entity and then questing a new timeSolid - sort of a call and response. (does this method handle the infinite race well? No. How can we fix that??)
    After each TimeSolid, when we increment the timePointer thing (which points to the time we are processing) and rid the relevant solids of any solids that ended before the next time


  A thought on efficiency:
    if these calculations prove to be too much, perhaps it would be easier to have groups of relevant solids for each section of the board, and deal with duplicates when time paralelpipeds cross into different parts of the board.
    
  **/
 
export class Point { // also may also be thought of as a Vector
  // generally, every method without "get-" modifies and then returns the orignial object.
  /**
   * @param {number} x
   * @param {number} y
   * @param {number} z the time coordinate of this point, in milliseconds, relative to GAME_START
   */
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  toString() {
    return "(" + this.x + ", " + this.y + ", " + this.z + ")";
  }
  clone() {
    return new Point(this.x, this.y, this.z); // does this need to have "new"?
  }


  add(point) {
    this.x += point.x;
    this.y += point.y;
    this.z += point.z;
    return this;
  }
  sub(point) {
    this.x -= point.x;
    this.y -= point.y;
    this.z -= point.z;
    return this;
  }
  getDot(vector) {
    const resX = this.x * vector.x;
    const resY = this.y * vector.y;
    const resZ = this.z * vector.z;
    return resX + resY + resZ;
  }
  cross(vector) {
    const newX = this.y * vector.z - this.z * vector.y;
    const newY = this.z * vector.x - this.x * vector.z;
    const newZ = this.x * vector.y - this.y * vector.x;
    this.x = newX;
    this.y = newY;
    this.z = newZ;
    return this;
  }
  scalarMultiply(c) {
    this.x *= c;
    this.y *= c;
    this.z *= c;
    return this;
  }
  getProjOnto(vector) {
    let v = vector.clone().normalize();
    return v.scalarMultiply(this.getDot(v));
  }
  getNorm() {
    this.norm = this.norm || Math.sqrt(this.getDot(this));
    return this.norm;
  }
  getNorm2() {
    this.norm2 = this.norm2 || this.getDot(this);
    return this.norm2;
  }
  normalize() {
    this.x /= this.getNorm();
    this.y /= this.norm;
    this.z /= this.norm;
    if (this.x < 0) this.scalarMultiply(-1);
    else if(this.x == 0 && this.y < 0) this.scalarMultiply(-1);
    else if(this.x == 0 && this.y == 0 && this.z < 0) this.scalarMultiply(-1);

    return this;
  }
  getDeterminant(point2, point3) {
    let l1 = this;
    let l2 = point2;
    let l3 = point3;
    return l1.x * l2.y * l3.z
      + l2.x * l3.y * l1.z
      + l3.x * l1.y * l2.z
      - l3.x * l2.y * l1.z
      - l2.x * l1.y * l3.z
      - l1.x * l3.y * l2.z;
  }
  abs(){
    if (this.x < 0) this.x *= -1;
    if (this.y < 0) this.y *= -1;
    if (this.z < 0) this.z *= -1;
    return this;
  }
  doSanityCheck(){
    // throw an error if any variable is undefined or null
    if (isNaN(this.x) || this.x == null ||
        isNaN(this.y) || this.y == null ||
        isNaN(this.z) || this.z == null ){
          console.log(this);
          throw new Error("Point/vector has variable with bad value");
    }
  }
  equals(point){
    return this.x == point.x && this.y == point.y && this.z == point.z;
  }
  isDangClose(point){
    const superSmolNum = 0.00001;
    return  Math.abs(this.x - point.x) < superSmolNum && 
            Math.abs(this.y - point.y) < superSmolNum && 
            Math.abs(this.z - point.z) < superSmolNum;
  }
  isScaledEquals(point){
    const a = this.clone().normalize();
    const b = point.clone().normalize().abs();
    // console.log(a);
    // console.log(b);
    return a.equals(b);
  }
}
export class Vector extends Point {
  constructor(x,y,t){
    super(x,y,t);
  }
}
export class Intersection extends Point {
  // crossing is a line
  constructor(crossing, t){ // crossing represents the line in which the two faces collide, it needs to be dropped to be paralell to the z-plane and set so that the z coord is the collision time
    try {
      let oldVectCpy = crossing.vector.clone();
      let newVect = oldVectCpy.sub(oldVectCpy.getProjOnto(new Point(0,0,1))); // newVect is paralell to the ground
      super(newVect.x, newVect.y, t);
    } catch (e) {
      console.log(crossing);
      throw e;
    }
    
  }
}
export class Line {
  /**
   * @param {Point} p1
   * @param {Point} p2
   */
  constructor(p1, p2) {
    this.point1 = p1.clone();
    this.point2 = p2.clone();
    this.vector = p2.clone().sub(p1);
  }
  toString() {
    return this.point1.toString() + " ----- " + this.point2.toString();
  }

  /**
   * @returns {Point}   vector representing the path from p1 to p2
   */
  getVector() {
    return this.vector;
  }

  // /**
  //  * @param {Face} plane   face whose plane you want to find the intersection with this line
  //  */
  // getIntersection(plane) { // important note: this does not check to see if it intersects the face.

  //   // note to self: dont flip them here becasue then the vector would be wrong
  //   if (this.point1.z > this.point2.z) throw new Error("BROKEN ASSUMPTIONS: this line is not in order of older point to newer point.");

  //   if (plane.getPlaneOffset(this.point1) > 0 && plane.getPlaneOffset(this.point2) <= 0) { // if 1st is outside, and 2nd is inside/on
  //     // number of vectors added to point1 that it takes to get to the intersection
  //     const s = (plane.equC - plane.asPlane().getDot(this.point1)) / plane.asPlane().getDot(this.vector);

  //     return this.point1.z + s * this.vector.z;
  //   } else {
  //     return null; // there can be no intersection worth recording
  //   }
  // }
  isPointBetweenBounds(lower, point, higher){
    if (lower.x <= point.x && higher.x >= point.x &&
      lower.y <= point.y && higher.y >= point.y &&
      lower.z <= point.z && higher.z >= point.z) return true;
    else return false;
  }
  getIntersection(line, axis, treatPointsAsBounds = false) { // important note: this does not check to see if it intersects the face.
    //we assume theyre not colinaer
    let rtrn = this.crosses(line);
    
    if (rtrn == false) return false;
    // console.log(".");
    if (!treatPointsAsBounds || 
      this.isPointBetweenBounds(line.point1, rtrn, line.point2) ||
      this.isPointBetweenBounds(line.point2, rtrn, line.point1)) {
        if (axis == 'x') return rtrn.x;
        if (axis == 'y') return rtrn.y;
        if (axis == 'z') return rtrn.z;
      }
    return false;
  }
  isColinear(line){
    const c = line.vector.x / this.vector.x;
    return (this.vector.y * c == line.vector.y && this.vector.z * c == line.vector.z);
  }
  crosses(line){
    // if (this.isColinear(line)) return line.point1; // colinear lines

    // solving p1 + c1 v1 = p = p2 + c2 v2
    //   as [v1 v2][c] = [p2 - p2]
    let v = [
      [this.vector.x, line.vector.x],
      [this.vector.y, line.vector.y],
      [this.vector.z, line.vector.z]
    ];
    const temp = this.point2.clone().sub(line.point1);
    // console.log(temp);
    let p = [temp.x, temp.y, temp.z];
    let c = solveLinEqu(v,p);
    if (c == false) return line.point1; // colinear lines
    let collisionPoint = this.vector.clone().scalarMultiply(c[0]).add(this.point1);
    return collisionPoint;
    // const [a, d] = [this.point1.x - line.point1.x, this.point2.y - line.point2.y];
    // const [b, e] = [-this.vector.x, -this.vector.y];
    // const [c, f] = [ line.vector.x,  line.vector.y];

    // const s = c*e - f*b
    // if (s === 0) { // parallel lines in the x and y dimensions
    //   const [a, d] = [this.point1.x - line.point1.x, this.point2.z - line.point2.z];
    //   const [b, e] = [-this.vector.x, -this.vector.z];
    //   const [c, f] = [ line.vector.x,  line.vector.z];

    //   const s = c*e - f*b
    //   if (s === 0) return false; // truely parallel lines

    //   let c1 = (a*e - d*b) / (s);
    //   let c2 = (d*c - a*f) / (s);

    //   const collisionPoint = this.vector.clone().scalarMultiply(c1).add(this.point1);
    //   if (collisionPoint === line.vector.clone().scalarMultiply(c2).add(line.point1)) return collisionPoint;
    //   return false;
    // } // parallel lines
    // let c1 = (a*e - d*b) / (s);
    // let c2 = (d*c - a*f) / (s);

    // const collisionPoint = this.vector.clone().scalarMultiply(c1).add(this.point1);
    // if (collisionPoint === line.vector.clone().scalarMultiply(c2).add(line.point1)) return collisionPoint;
    return false;
  }
  intersectsFace(face){
    // are the points on different sides of the plane? OR do they both lie in the plane?
    const c1 = face.getPlaneOffset(this.point1);
    const c2 = face.getPlaneOffset(this.point2);
    if (c1 === 0 || c2 === 0){
      if (face.contains(this.point1)) return this.point1;
      if (face.contains(this.point2)) return this.point2;
      if (c1 === 0 && c2 === 0){
        for (const nextLine of face.asLines()){
          const crossing = this.crosses(nextLine);
          if (crossing != false) return crossing;
        }
      }
      return false;
    } else if (c1 > 0 ^ c2 > 0) {
      goalP = this.point1.clone().add(this.vector.scalarMultiply(c1/(c1-c2)));
      return face.contains(goalP, false);
    }
  }
  determinant(line2, line3) {
    let l1 = this.vector;
    let l2 = line2.vector;
    let l3 = line3.vector;
    return l1.x * l2.y * l3.z
      + l2.x * l3.y * l1.z
      + l3.x * l1.y * l2.z
      - l3.x * l2.y * l1.z
      - l2.x * l1.y * l3.z
      - l1.x * l3.y * l2.z;
  }
  getOffsetToLine(otherLine) {
    /**
     *  We treat the problem as a system
     * [l1 l2 l1xl2][scalars] = p1-p2 (any two points on the lines)
     *  We want the last scalar times the l1xl2 vector
     */
    
    let l1 = this.vector;
    let l2 = otherLine.vector;
    let l3 = l1.clone().cross(l2);

    let v = this.point1.clone().sub(otherLine.point1);

    // using cramer's rule
    let thirdScalar = v.getDeterminant(l1, l2) / l3.getDeterminant(l1, l2);

    return l3.scalarMultiply(thirdScalar);
  }
  doSanityCheck(){
    // throw an error if any variable is undefined or null
    if (this.point1 == null ||
        this.point1 == null ||
        this.vector == null ){
          console.log(this);
          throw new Error("Line has variable with bad value");
        }
    this.point1.doSanityCheck();
    this.point1.doSanityCheck();
    this.vector.doSanityCheck();
  }
}
export class Face {
  constructor(p0, p1, p2, p3) {
    /**
     *   p2 --- p3
     *    |     |
     *   p0 --- p1
    */
    // if (p0.z === -1) throw new Error("WHAH");
    this.p0 = p0.clone();
    this.p1 = p1.clone();
    this.p2 = p2.clone();
    this.p3 = p3.clone();

    // I forgot about the getPlane() function...
    //
    // let normVectCandidates = [
    //   this.getNormalVector(new Point(...[1, 0, 0])),
    //   this.getNormalVector(new Point(...[0, 1, 0])),
    //   this.getNormalVector(new Point(...[0, 0, 1]))
    // ]
    // this.normalVector = null;
    // for (candidate of normVectCandidates){
    //   if (candidate.getNorm() > 0.0001) {
    //     this.normalVector = candidate.normalize();
    //     break;
    //   }
    // }
    // if (this.normalVector === null) throw error("Face is not a plane");

    this.lines;
  }
  getNormalVector(startingVector){ // graham schmit process
    let vector = startingVector;
    vector.sub(vector.getProjOnto(this.p0));
    vector.sub(vector.getProjOnto(this.p1));
    vector.sub(vector.getProjOnto(this.p2));
    vector.sub(vector.getProjOnto(this.p3));
    return vector;
  }
  toString() {
    return "Face:\n" +
      "\t" + this.p0.toString() + ",\n" +
      "\t" + this.p1.toString() + ",\n" +
      "\t" + this.p2.toString() + ",\n" +
      "\t" + this.p3.toString() + "\n";
  }
  asLines() { // generator that yields the bottom, top then sides of the face.
    if (!this.lines){
      this.lines = [
        new Line(this.p0, this.p1),
        new Line(this.p1, this.p3),
        new Line(this.p3, this.p2),
        new Line(this.p2, this.p0) // keeping them in the right order is important
      ]; // TODO, wanted this to be yields
    }
    return this.lines;
  }
  getPlane() { // meaning return the vector perp to that plane, according to the right hand rule, pointing out of the figure above
    let l1 = this.p1.clone().sub(this.p0);
    const l2 = this.p2.clone().sub(this.p0);
    this.equ = this.equ || l1.cross(l2);
    if (this.equ.x == 0 && this.equ.y == 0 && this.equ.z == 0) {
      console.log(this);
      throw Error("The zero vector is not a valid equation");
    }
    return this.equ;
  }
  // intersects is for planes
  // crosses is for lines
  // contains is for points
  intersects(face){ // asumes p0 is the first point in time, and that the faces only instersect at one point in time (unless they are touching sides)
    // for (let line of face.asLines()){
    //   const crossing = this.crosses(line);
    //   if (crossing != false) return crossing;
    // }
    // for (let line of this.asLines()){
    //   const crossing = face.crosses(line);
    //   if (crossing != false) return crossing;
    // }
    const pln1 = this.getPlane();
    const pln2 = face.getPlane();
    // console.log(pln1);
    // console.log(pln2);
    if (pln1.isScaledEquals(pln2)) return false;
    const vect = pln1.clone().cross(pln2); // we now have the direction of the plane, now we need a starting point
    // console.log(vect);
    const c1 = this.getEquC();
    const c2 = face.getEquC();
    // console.log(c1);
    // console.log(c2);

    // solve the system of equations
    const eq1 = [pln1.x, pln1.y, pln1.z];
    const eq2 = [pln2.x, pln2.y, pln2.z];
    let ans, pnt;
    if ((ans = solveLinEqu([eq1, eq2, [1,0,0]],[c1,c2,0])) != false) pnt = new Point(...ans); // try setting the x cord to 0
    else if ((ans = solveLinEqu([eq1, eq2, [0,1,0]],[c1,c2,0])) != false) pnt = new Point(...ans); // try setting the y cord to 0
    else if ((ans = solveLinEqu([eq1, eq2, [0,0,1]],[c1,c2,0])) != false) pnt = new Point(...ans); // try setting the z cord to 0
    // let det = pln1.x * pln2.y - pln1.y  * pln2.x;
    // let pnt;
    // if (det == 0){ // then we'll try with something other than the z value being 0 -> the next det shouldnt be zero bc that would mean the lines are colinear
    //   det = pln1.x * pln2.z - pln1.z  * pln2.x;
    //   if (det == 0){ // then we'll try with something other than the z value being 0 -> the next det shouldnt be zero bc that would mean the lines are colinear
    //     det = pln1.y * pln2.z - pln1.z  * pln2.y;
    //     if (det == 0) return false; //throw Error("vectors are causing problems"); // smth happened...
    //     const y = (c1 * pln2.z - c2 * pln1.z) / det;
    //     const z = (pln1.y * c2 - pln2.y * c1) / det;
    //     pnt = new Point(0, y, z);
  
    //   } else {
    //   const x = (c1 * pln2.z - c2 * pln1.z) / det;
    //   const z = (pln1.x * c2 - pln2.x * c1) / det;
    //   pnt = new Point(x, 0, z);
    //   }

    // } else { // with the z value being 0
    //   const x = (c1 * pln2.y - c2 * pln1.y) / det;
    //   const y = (pln1.x * c2 - pln2.x * c1) / det;
    //   pnt = new Point(x, y, 0);
    // }
    try {
      pnt.doSanityCheck();
    } catch(e){
      console.log(face);
      console.log(this);

      console.log(pln1);
      console.log(pln2);
      
      console.log(c1);
      console.log(c2);
      throw e;
    }
    const rtrn = new Line(pnt, vect.add(pnt));
    rtrn.doSanityCheck();
    return rtrn;
  }
  // crosses(line){
  //   // are the points on different sides of the plane? OR do they both lie in the plane?
  //   // console.log(line);
  //   const c1 = this.getPlaneOffset(line.point1);
  //   const c2 = this.getPlaneOffset(line.point2);
  //   if (c1 === 0 || c2 === 0){
  //     if (this.contains(line.point1)) return line.point1;
  //     if (this.contains(line.point2)) return line.point2;
  //     if (c1 === 0 && c2 === 0){
  //       for (const nextLine of this.asLines()){
  //         const crossing = nextLine.crosses(line);
  //         if (crossing != false) return crossing;
  //       }
  //     }
  //     return false;
  //   } else if (c1 > 0 ^ c2 > 0) {
  //     let goalP = line.point1.clone().add(line.vector.scalarMultiply(c1/(c1-c2)));
  //     return this.contains(goalP, false);
  //   }
  //   return false;
  // }
  // contains(point, checkIfOnPlane = true){
  //   if (checkIfOnPlane && this.getPlaneOffset(point) !== 0) return false;

  //   let firstC = 0;
  //   for (const nextLine of this.asLines()){ // check to make sure no points are on different sides of the line
      
  //     const newPlane = new Face(nextLine.point1, nextLine.point2, 
  //       nextLine.point1.clone().add(this.getPlane()),
  //       nextLine.point1.clone().add(this.getPlane()));
  //     let c = newPlane.getPlaneOffset(point);
  //     if (firstC != 0 && c != 0){
  //       if (c > 0 ^ firstC > 0) return false;
  //     } else if (c != 0) firstC = c;
  //   }
  //   return point;
  // }
  /**
   * @param {Point} point
   * @returns {Number}   basically represents how far off the point is from the plane (+ if in the same direction as the plane)
   */
  getEquC(){
    this.equC = this.equC || this.getPlane().getDot(this.p0); // the constant in the equation to the plane
    return this.equC;
  }
  getPlaneOffset(point) {
    // console.log(point);
    this.doSanityCheck();
    return this.getPlane().getDot(point) - this.getEquC();
  }
  doSanityCheck(){
    // throw an error if any variable is undefined or null
    // if (isNaN(this.x)  || this.x  == null ||
    //     isNaN(this.y)  || this.y  == null ||
    //     isNaN(this.r1) || this.r1 == null ||
    //     isNaN(this.r2) || this.r2 == null ||
    //     isNaN(this.t1) || this.t1 == null ||
    //     isNaN(this.t2) || this.t2 == null ||
    //     this.center == null ||
    //     this.line   == null ||
    //     this.vector == null ){
    //       console.log(this);
    //       throw new Error("TimeSolid has variable with bad value");
    //     }
    // this.center.doSanityCheck();
    // this.line.doSanityCheck();
    // this.vector.doSanityCheck();
    if (this.p0 == null ||
        this.p1 == null ||
        this.p2 == null ||
        this.p3 == null){
          console.log(this);
          throw new Error("TimeSolid has variable with bad value");
    }
      this.p0.doSanityCheck();
      this.p1.doSanityCheck();
      this.p2.doSanityCheck();
      this.p3.doSanityCheck();
  }

}
class TimeSolid {
  /**
   * @param {String} type   name of class being instantiated
   * @param {Number} x      coordinate of the center of the shape at time t1
   * @param {Number} y      coordinate of the center of the shape at time t1
   * @param {Number} r1     radius of the base along the x-axis
   * @param {Number} r2     radius of the base along the y-axis
   * @param {Number} t1     time in millisecods from the start of the game at which this time solid begins
   * @param {Number} t2     time in millisecods from the start of the game at which this time solid ends
   * @param {Point}  vector vector of movement of this shape through time: (dx, dy, dt).
   */
  constructor(type, x, y, r1, r2, t1, t2, vector) {
    this.type = type; // do i need to copy this? prob not

    // x and y coordinates represent the center of the object
    this.x = x;
    this.y = y;

    this.r1 = r1;
    this.r2 = r2;

    this.t1 = t1;
    this.t2 = t2;

    this.center = new Point(x, y, t1);
    this.line = new Line(this.center, this.center.clone().add(vector));
    this.vector = vector.clone();
  }
  getFaces() {
    throw new Error("getFaces has not been initialized correctly");
  }
  getIntersection(timeSolid) {
    throw new Error("getIntersection has not been initialized correctly");
  }
  doSanityCheck(){
    // throw an error if any variable is undefined or null
    if (isNaN(this.x)  || this.x  == null ||
        isNaN(this.y)  || this.y  == null ||
        isNaN(this.r1) || this.r1 == null ||
        isNaN(this.r2) || this.r2 == null ||
        isNaN(this.t1) || this.t1 == null ||
        isNaN(this.t2) || this.t2 == null ||
        this.center == null ||
        this.line == null ||
        this.vector == null){
          console.log(this);
          throw new Error("Face has variable with bad value");
    }
    this.center.doSanityCheck();
    this.line.doSanityCheck();
    this.vector.doSanityCheck();
  }
}
export class TimeParallelepiped extends TimeSolid {

  /**  point indicies (c marks the x,y,t1 center)
     *    6-----7                           6-----7
     *    |\    |\                >        / \   / \ 
     *    | 4---+-5               >       /   4-----5
     *    2-+---3 |      t        >      2---/-3   /     t  vector
     *     \| c  \|    y |        >       \ /c  \ /    y | /
     *      0-----1     \|__x              0-----1      \|/_x
     */
  pointsInFaces = [ // constructed with the faces pointing out of the shape (right hand rule of [0]->[1] and [0]->[2]). 
    // last point is always all the way across the shape from the first

    [0, 2, 1, 3], // bottom face
    [4, 5, 6, 7], // top face
    [0, 1, 4, 5], // "front" p0 face
    [3, 2, 7, 6], // "back" p3 face
    [1, 3, 5, 7], // "right-side" p1 face
    [2, 0, 6, 4]  // "left-side" p2 face      
  ];

  /**
   * @param {Number} x      the coordinate of the center of the shape at time t1
   * @param {Number} y      the coordinate of the center of the shape at time t1
   * @param {Number} w      the width of the base at t1 in the x-axis
   * @param {Number} l      the legnth of the base at t1 in the y-axis
   * @param {Number} t1     the time in millisecods from the start of the game at which this time solid begins
   * @param {Number} t2     the time in millisecods from the start of the game at which this time solid ends
   * @param {Point}  vector the vector of movement of this shape through time: (dx, dy, dt).
   */
  constructor(x, y, w, l, t1, t2, vector) {
    // x and y coordinates represent the center of the object
    super("parallelepiped", x, y, w / 2, l / 2, t1, t2, vector);

    /**  point indicies (c marks the x,y,t1 center)
     *    6-----7                           6-----7
     *    |\    |\                >        / \   / \ 
     *    | 4---+-5               >       /   4-----5
     *    2-+---3 |      t        >      2---/-3   /     t  vector
     *     \| c  \|    y |        >       \ /c  \ /    y | /
     *      0-----1     \|__x              0-----1      \|/_x
     */
    
    vector.doSanityCheck();
    if (vector.z === 0) {
      throw Error("Probably shouldn't have timesolid with no duration");
    }
    this.dx = vector.x / vector.z;
    this.dy = vector.y / vector.z;
    this.dt = t2 - t1;
    if (this.dt < 0) throw Error("Timesolid with negative duration!");

    this.points = [
      new Point(this.x - this.r1, this.y - this.r1, t1),
      new Point(this.x + this.r1, this.y - this.r1, t1),
      new Point(this.x - this.r1, this.y + this.r1, t1),
      new Point(this.x + this.r1, this.y + this.r1, t1),
      new Point(this.x - this.r1 + this.dx, this.y - this.r1 + this.dy, t2),
      new Point(this.x + this.r1 + this.dx, this.y - this.r1 + this.dy, t2),
      new Point(this.x - this.r1 + this.dx, this.y + this.r1 + this.dy, t2),
      new Point(this.x + this.r1 + this.dx, this.y + this.r1 + this.dy, t2),

      

    ]
    this.faces = [null, null, null, null, null, null];
    this.getFaces();
  }
  getFaces() {
    if (this.faces[0] == null){
      // let rtrn = [];
      for (let i = 0; i < 6; i++) {
        const pnts = this.pointsInFaces[i];
        // console.log(pnts);
        this.faces[i] = new Face(this.points[pnts[0]], this.points[pnts[1]], this.points[pnts[2]], this.points[pnts[3]]);

        // rtrn.push(this.faces[i]); // TODO, wanted this to be yields
      }
    }
    return this.faces;
  }
  utility_getMiddle2of4(arr){
    let count = 0;
    while (arr.length > 2) {
      const mn = Math.min(arr);
      arr.splice(arr.indexOf(mn),1); // remove 1 min

      const mx = Math.max(arr);
      arr.splice(arr.indexOf(mx),1); // remove 1 max

      if (count++ > 50) throw Error("infinite loop!");
    }
    return arr;
  }
  utility_getMinOfOverlapPlanesAndLine(fc1, fc2, line, axis){
    // console.log("tracking intersection");
    let lineSegTs1 = fc1.asLines().map((l) => line.getIntersection(l, axis, true));
    let lineSegTs2 = fc2.asLines().map((l) => line.getIntersection(l, axis, true));
    
    lineSegTs1 = lineSegTs1.filter((l) => l !== false);
    lineSegTs2 = lineSegTs2.filter((l) => l !== false);

    if (lineSegTs1.length < 2 || lineSegTs2.length < 2) return false;
    if (lineSegTs1.length == 4){
      lineSegTs1 = this.utility_getMiddle2of4(lineSegTs1);
    }
    if (lineSegTs2.length == 4){
      lineSegTs2 = this.utility_getMiddle2of4(lineSegTs2);
    }
    
    let arr = lineSegTs1.concat(lineSegTs2);

    if (Math.min(arr) === Math.max(arr)) return arr[0]; // whole array values are the same
    let arrOfSortedIndicies = Array.from(Array(arr.length).keys()).sort((a,b) => arr[a]-arr[b])
    let arr2 = arrOfSortedIndicies.map((a) => a < 2); 
    // this array is now the order of elements from the original array, but as a bool that represesnts if theyre from the first lineSetTs1;
    // [3,8,100,2] => [F,T,T,F]
    // [4,5,6,2] => [F,T,T,F]

    if ( arr2[0] ==  arr2[1]) return false; // first two bounds are from first shape or seconds shape (ie they dont overlap)
    else {
      return arr[arrOfSortedIndicies[1]]; // return the second to least value
    }
  }
  getIntersection(timeSolid) {
    if (this.t1 == this.t2 || timeSolid.t1 == timeSolid.t2) throw Error("Cannot model interaction of timesolid with no duration!");
    if (this.t1 > this.t2 || timeSolid.t1 > timeSolid.t2) throw Error("Timesolid with negative duration!");
    
    this.doSanityCheck();
    timeSolid.doSanityCheck();

    // catch a lazy case of neither solid moving
    // if (this.dx === 0 && this.dy === 0 && 
    //   timeSolid.dx === 0 && timeSolid.dy === 0) {
        
    //     return null;
    //   }

    // console.log("checking intersection with math");
    switch (timeSolid.type){ // because they can only touch once, locating one intersection is good enough to return
      case "parallelepiped":
        // ADD BACK IN !!!!
        // // are they even in the same neighborhood??
        const distFromBase = this.center.clone().sub(timeSolid.center);
        let save1 = distFromBase.clone();
        // console.log(distFromBase);
        const widthOffset = new Point(this.r1 + timeSolid.r1, this.r2 + timeSolid.r2, 0);
        let save2 = widthOffset.clone();
        // console.log(widthOffset);
        // console.log(widthOffset);
        widthOffset.doSanityCheck();
        distFromBase.abs().sub(widthOffset);
        let save3 = distFromBase.clone();
        // console.log("checking intersection!");
        
        
        // console.log("vect");
        // console.log(this.vector);
        // console.log(timeSolid.vector);
        // at this point if distFromBase < 0 then they are intersecting! optimize
        if (distFromBase.x <= 0 && distFromBase.y <= 0) {
          // console.log("trivial intersection!");
          return true;
        }
        // console.log(timeSolid);
        
        let maxTravel = this.vector.clone().scalarMultiply(this.vector.z).sub(timeSolid.vector.clone().scalarMultiply(timeSolid.vector.z)).abs();
        distFromBase.sub(maxTravel);
        if (distFromBase.x <= 0 && distFromBase.y <= 0);// console.log("trivially not not intersecting!");
        else return null;
        
        console.log(save1);
        console.log(save2);
        console.log(save3);
        console.log(maxTravel);
        console.log(distFromBase);

        console.log("");
        console.log(this.vector);
        console.log(timeSolid.vector);
        // // are the centers of the lines (extending infinetly in both directions, sufficiently close?)
          // const trueOffset = this.line.getOffsetToLine(timeSolid.line).sub(widthOffset);
          // if (trueOffset.x > 0 || trueOffset.y > 0) return null;

        // let minT = null;
        // let vect = this.vector.clone().sub(timeSolid.vector);
        // for (const thisFace of this.getFaces().slice(2)){
        //   for (const thatFace of timeSolid.getFaces().slice(2)){
        //     if (thatFace.p0.x = thatFace.p1.x) { // wall is horizonally aligned

        //     }
        //     let suggestionCollision = 
        //   }
        // }

          // do they overlap?
        let minT = null; // wintergreen     lol... its minty.. get it? minT?
        let minCrossing;
        for (const thisFace of this.getFaces().slice(2)){ // only iterate through sides of faces
          thisFace.doSanityCheck();
          for (const thatFace of timeSolid.getFaces().slice(2)){ // only iterate through sides of faces
            thatFace.doSanityCheck();
            const crossing = thisFace.intersects(thatFace);
            // console.log(crossing);
            if (crossing == false) continue; // if the planes are parallel
            let suggestionT;
            if (crossing.vector.z == 0){ // if the line is paralell to the ground
              // console.log(this.t2);
              suggestionT = crossing.point1.z;
              if (crossing.vector.x == 0){ // if line is paralell to the x-axis too.. good gravy! so do it w/ repect to the y
                // console.log("Y");
                const r = this.utility_getMinOfOverlapPlanesAndLine(thisFace, thatFace, crossing, 'y');
                // console.log(r);
                if (r == false) continue;
              } else{
                // console.log("X");
                const r = this.utility_getMinOfOverlapPlanesAndLine(thisFace, thatFace, crossing, 'x');
                // console.log(r);
                if (r == false) continue;
              }
              // !!!! catch special case where all Ts are the same and T doesnt lie on the plane intersection :(
            } else {
              suggestionT = this.utility_getMinOfOverlapPlanesAndLine(thisFace, thatFace, crossing, 'z');
              if (suggestionT == false) continue;
              console.log(crossing);
              throw Error("something broke");
              continue; // a shortcut for now,, because all objects are oriente in line iwth the horiz. and vert. axis
              // console.log("Z");
              
              
            }
            // console.log(thisFace);
            // console.log(thatFace);
            // console.log(suggestionT);
            if (suggestionT > timeSolid.t2 || suggestionT > this.t2) {
              console.log("Concerning Event: Collision returned is after the timeSolid!");
              continue;
            }
            if (suggestionT < timeSolid.t1 || suggestionT < this.t1) {
              console.log("Concerning Event: Collision returned is before the timeSolid!");
              continue;
            }
            if (minT == null || suggestionT < minT) {
              minT = suggestionT;
              minCrossing = crossing;
            }
          }
        }
        if (minT == null) return null;
        return new Intersection(minCrossing, minT);
      case "cylinder":
        return null;
    }
  }
}
export class TimeCylinder extends TimeSolid { // technically it would be a TimeObliqueEllipticCylinder, but... yeah..
  /**
   * @param {Number} x the coordinate of the center of the shape at time t1
   * @param {Number} y the coordinate of the center of the shape at time t1
   * @param {Number} ------------------FIX
   * @param {Number} ------------------FIX
   * @param {Number} t1 the time in millisecods from the start of the game at which this time solid begins
   * @param {Number} t2 the time in millisecods from the start of the game at which this time solid ends
   * @param {Point} vector the vector of movement of this shape through time: (dx, dy, dt).
   */
  constructor(x, y, r1, r2, t1, t2, vector) {
    super("cylinder", x, y, r1, r2, t1, t2, vector);
  }
  getFaces() {
    // idk how to implement this yet
  }
}

function rejoice() {
  console.log("YES!! :)");
}

function solveLinEqu(equations, cArr){
  let matrix = [];
  let rtrn = [];
  if (equations.length != cArr.length) throw Error("solveLinEq: invalid arguement length");
  if (equations.length < equations[0].length) throw Error("solveLinEq: not enough equations for definite solution");
  for (let i = 0; i < equations.length; i++) matrix.push([...equations[i],cArr[i]]);
  for (let i = 0; i < matrix.length; i++)
    for (let j = 0; j < matrix[0].length; j++) 
      if (isNaN(matrix[i][j])) 
        throw Error("solveLinEq: non-numeric inputs!");
  for (let i = 0; i < matrix.length; i++){
    // for (let p = 0; p < matrix.length; p++)
    //   console.log(matrix[p]);
    // console.log("solving...");

    // get leading 1
    for (let j = i; j < matrix.length; j++){
      if (matrix[j][i] == 0) continue;
      if (i != j){ // swap the rows
        let temp = matrix[i];
        matrix[i] = matrix[j];
        matrix[j] = temp;
      }
      // make the now non constant leading term of the ith row 1
      const c = matrix[i][i];
      // console.log(c);
      matrix[i] = matrix[i].map(x => x/c); 
    }
    // make zeros underneath
    for (let j = i+1; j < matrix.length; j++){
      const c = matrix[j][i];
      if (c == 0) continue;
      for (let k = 0; k < matrix[0].length; k++){ // could reduce by only doing the c term
        matrix[j][k] = matrix[j][k]/c - matrix[i][k];
      }
    }
  }
  // for (let p = 0; p < matrix.length; p++)
  //     console.log(matrix[p]);
  for (let i = 0; i < matrix.length; i++)
      rtrn.push(matrix[i][matrix[0].length-1]);

  let isBadSolution = true;
  for (let i = 0; i < matrix[0].length-1; i++) if (matrix[matrix.length-1][i] != 0) isBadSolution = false;
  matrix[0][0].length;
  if (isBadSolution && matrix[matrix.length-1][matrix.length[0]-1] != 0) return false;


  //check answers
  for (let i = 0; i < equations.length; i++){
    let sum = 0;
    for (let j = 0; j < equations[i].length; j++){
      const c = equations[i][j];
      for (let k = 0; k < equations[i].length; k++){
        equations[i][k] -= matrix[j][k] * c;
      }
      sum += c * rtrn[j];
    }
    
    if(Math.abs(sum - cArr[i]) > 0.000001) {
      for (let p = 0; p < equations.length; p++)
        console.log(equations[p]);
      for (let p = 0; p < matrix.length; p++)
        console.log(matrix[p]);
      console.log(sum + " " + cArr[i]);
      throw Error("solveLinEqu: answer not exact!");

    }
  }

  return rtrn;
}