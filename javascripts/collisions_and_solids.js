import { LinkedList } from "./dataStructures/LinkedList.js";
import { PriorityQueue } from "./dataStructures/PriorityQueue.js";


export var ALL_TIME_SOLIDS = new LinkedList();
export var LINKED_LIST_POINTER;

export var COLLISION_SOON_SOLIDS = new PriorityQueue([], (a, b) => { return a.t1 < b.t1; }); // do we even need this?
export var COLLISION_RELEVANT_SOLIDS = new PriorityQueue([], (a, b) => { return a.t2 < b.t2; });

/**
  0. Load all relavant TimeSolids to the COLLISION_RELEVANT_SOLIDS (Maybe change the ALL_TIME_SOLIDS to a cross-linked list, which would sort the elments with respect to start and end times). All relevant TimeSolids are all those who have not finished by the start time of your catch-up sweep.
  1. run through TimeSolids until you reach a) the end or b) the current time
    For each TimeSolid:
      a. find any collisions with TimeSolids in RELEVANT_SOLIDS queue
        i.  check for locality -> get line for each, see if it ever gets near enough to concern
          line begins at the 2D spacial point of first time of common existance, end at last time of common existance..... or check the distance of the vector from one lime to the other in 3d space (the cross product of the two lines) for sufficient locality... idk how to find the closest point on each line though. We could also test various levels of locality.. making a general box first..
        ii. check for collision (except on the top and bottom faces? - be sure to make that new solids dont cross though!!!!!!!)
          For each Collision:
            A) Cut the TimeSolids, adding the new solids to the linked List (for efficiency, add an option to have a "first guess".. or just add it at the current time? would the LINKED_LIST_POINTER be pointing to the right time? almost.. it would be after the block of blocks that start at that time.. but very close)
              I - New solids are generated by applying a rule to the entity and then questing a new timeSolid - sort of a call and response. (does this method handle the infinite race well? No. How can we fix that??)
    After each TimeSolid, when we increment the timePointer thing (which points to the time we are processing) and rid the relevant solids of any solids that ended before the next time


  A thought on efficiency:
    if these calculations prove to be too much, perhaps it would be easier to have groups of relevant solids for each section of the board, and deal with duplicates when time paralelpipeds cross into different parts of the board.
    
  **/
class Point { // also may also be thought of as a Vector
  // generally, every method without "get-" modifies and then returns the orignial object.
  /**
   * @param {number} x
   * @param {number} y
   * @param {number} z the time coordinate of this point, in milliseconds, relative to GAME_START
   */
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  toString() {
    return "(" + this.x + ", " + this.y + ", " + this.z + ")";
  }
  copy() {
    return new Point(this.x, this.y, this.z); // does this need to have "new"?
  }


  add(point) {
    this.x += point.x;
    this.y += point.y;
    this.z += point.z;
    return this;
  }
  sub(point) {
    this.x -= point.x;
    this.y -= point.y;
    this.z -= point.z;
    return this;
  }
  getDot(vector) {
    const resX = this.x * vector.x;
    const resY = this.y * vector.y;
    const resZ = this.z * vector.z;
    return resX + resY + resZ;
  }
  cross(vector) {
    const newX = this.y * vector.z - this.z * vector.y;
    const newY = this.x * vector.z - this.z * vector.x;
    const newZ = this.x * vector.y - this.y * vector.x;
    this.x = newX;
    this.y = newY;
    this.z = newZ;
    return this;
  }
  scalarMultiply(c) {
    this.x *= c;
    this.y *= c;
    this.z *= c;
    return this;
  }
  getProjOnto(vector) {
    var v = vector.copy().normalize();
    return v.scalarMultiply(this.dot(v));
  }
  getNorm() {
    this.norm = this.norm || Math.sqrt(this.getDot(this));
    return this.norm;
  }
  normalize() {
    this.x /= this.getNorm();
    this.y /= this.norm;
    this.z /= this.norm;
    return this;
  }


}
class Line {
  /**
   * @param {Point} p1
   * @param {Point} p2
   */
  constructor(p1, p2) {
    this.point1 = p1.copy();
    this.point2 = p2.copy();
    this.vector = p2.copy().sub(p1);
  }
  toString() {
    return this.point1.toString() + " ----- " + this.point2.toString();
  }

  /**
   * @returns {Point}   vector representing the path from p1 to p2
   */
  getVector() {
    return this.vector;
  }

  /**
   * @param {Face} plane   face whose plane you want to find the intersection with this line
   */
  getIntersection(plane) { // important note: this does not check to see if it intersects the face.

    // note to self: dont flip them here becasue then the vector would be wrong
    if (this.point1.z > this.point2.z) throw new Error("BROKEN ASSUMPTIONS: this line is not in order of older point to newer point.");

    if (plane.getPlaneOffset(this.point1) > 0 && plane.getPlaneOffset(this.point2) <= 0) { // if 1st is outside, and 2nd is inside/on
      // number of vectors added to point1 that it takes to get to the intersection
      const s = (plane.equC - plane.asPlane().getDot(this.point1)) / plane.asPlane().getDot(this.vector);

      return this.point1.z + s * this.vector.z;
    } else {
      return null; // there can be no intersection worth recording
    }
  }
  determinant(line2, line3) {
    var l1 = this.vector;
    var l2 = line2.vector;
    var l3 = line3.vector;
    return l1.x * l2.y * l3.z
      + l2.x * l3.z * l1.z
      + l3.x * l1.z * l2.z
      - l3.x * l2.y * l1.z
      - l2.x * l1.y * l3.z
      - l1.x * l3.y * l2.z;
  }
  getDistanceToLine(otherLine) {
    /**
     *  We treat the problem as a system
     * [l1 l2 l1xl2][scalars] = p1-p2 (any two points on the lines)
     *  We want the last scalar times the l1xl2 vector
     */
    
    var l1 = this.vector;
    var l2 = otherLine.vector;
    var l3 = l1.copy().cross(l2);

    var v = this.point1.copy().sub(otherLine.point1);

    // using cramer's rule
    var thirdScalar = v.determinant(l1, l2) / l3.determinant(l1, l2);

    return l3.scalarMultiply(thirdScalar).getNorm();
  }
}
class Face {
  constructor(p0, p1, p2, p3) {
    /**
     *   p2 --- p3
     *    |     |
     *   p0 --- p1
    */
    this.p0 = p0.copy();
    this.p1 = p1.copy();
    this.p2 = p2.copy();
    this.p3 = p3.copy();
  }
  toString() {
    return "Face:\n" +
      "\t" + this.p0.toString() + ",\n" +
      "\t" + this.p1.toString() + ",\n" +
      "\t" + this.p2.toString() + ",\n" +
      "\t" + this.p3.toString() + "\n";
  }
  asLines() { // generator that yields the bottom, top then sides of the face.
    return [new Line(this.p0, this.p1),
    new Line(this.p2, this.p3),
    new Line(this.p0, this.p2),
    new Line(this.p1, this.p3)]; // TODO, wanted this to be yields
  }
  getPlane() { // meaning return the vector perp to that plane, according to the right hand rule, pointing out of the figure above
    this.equ = this.equ || this.p1.copy().sub(this.p0).cross(this.p2.copy().sub(this.p0));
    return this.equ;
  }

  /**
   * @param {Point} point
   * @returns {Number}   basically represents how far off the point is from the plane (+ if in the same direction as the plane)
   */
  getPlaneOffset(point) {
    this.equC = this.equC || this.getPlane().getDot(this.p0); // the constant in the equation to the plane
    return this.getPlane().getDot(point) - this.equC;
  }

}
class TimeSolid {
  /**
   * @param {String} type   name of class being instantiated
   * @param {Number} x      coordinate of the center of the shape at time t1
   * @param {Number} y      coordinate of the center of the shape at time t1
   * @param {Number} r1     radius of the base along the x-axis
   * @param {Number} r2     radius of the base along the y-axis
   * @param {Number} t1     time in millisecods from the start of the game at which this time solid begins
   * @param {Number} t2     time in millisecods from the start of the game at which this time solid ends
   * @param {Point}  vector vector of movement of this shape through time: (dx, dy, dt).
   */
  constructor(type, x, y, r1, r2, t1, t2, vector) {
    this.type = type; // do i need to copy this? prob not

    // x and y coordinates represent the center of the object
    this.x = x;
    this.y = y;

    this.r1 = r1;
    this.r2 = r2;

    this.t1 = t1;
    this.t2 = t2;
    this.vector = vector.copy();
  }
  getFaces() {
    throw new Error("getFaces has not been initialized correctly");
  }
  getIntersection(timeSolid) {
    throw new Error("getIntersection has not been initialized correctly");
  }

}
export class TimeParallelepiped extends TimeSolid {

  /**  point indicies (c marks the x,y,t1 center)
     *    6-----7                           6-----7
     *    |\    |\                >        / \   / \ 
     *    | 4---+-5               >       /   4-----5
     *    2-+---3 |      t        >      2---/-3   /     t  vector
     *     \| c  \|    y |        >       \ /c  \ /    y | /
     *      0-----1     \|__x              0-----1      \|/_x
     */
  pointsInFaces = [ // constructed with the faces pointing out of the shape (right hand rule of [0]->[1] and [0]->[2]). 
    // last point is always all the way across the shape from the first

    [0, 2, 1, 3], // bottom face
    [4, 5, 6, 7], // top face
    [0, 1, 4, 5], // "front" p0 face
    [3, 2, 7, 6], // "back" p3 face
    [1, 3, 5, 7], // "right-side" p1 face
    [2, 0, 6, 4]  // "left-side" p2 face      
  ];

  /**
   * @param {Number} x      the coordinate of the center of the shape at time t1
   * @param {Number} y      the coordinate of the center of the shape at time t1
   * @param {Number} w      the width of the base at t1 in the x-axis
   * @param {Number} l      the legnth of the base at t1 in the y-axis
   * @param {Number} t1     the time in millisecods from the start of the game at which this time solid begins
   * @param {Number} t2     the time in millisecods from the start of the game at which this time solid ends
   * @param {Point}  vector the vector of movement of this shape through time: (dx, dy, dt).
   */
  constructor(x, y, w, l, t1, t2, vector) {
    // x and y coordinates represent the center of the object
    super("parallelepiped", x, y, w / 2, l / 2, t1, t2, vector);

    /**  point indicies (c marks the x,y,t1 center)
     *    6-----7                           6-----7
     *    |\    |\                >        / \   / \ 
     *    | 4---+-5               >       /   4-----5
     *    2-+---3 |      t        >      2---/-3   /     t  vector
     *     \| c  \|    y |        >       \ /c  \ /    y | /
     *      0-----1     \|__x              0-----1      \|/_x
     */
    const dx = vector.x / vector.z;
    const dy = vector.y / vector.z;

    this.points = [
      new Point(this.x - this.r1, this.y - this.r1, t1),
      new Point(this.x + this.r1, this.y - this.r1, t1),
      new Point(this.x - this.r1, this.y + this.r1, t1),
      new Point(this.x + this.r1, this.y + this.r1, t1),

      new Point(this.x - this.r1 + dx, this.y - this.r1 + dy, t2),
      new Point(this.x + this.r1 + dx, this.y - this.r1 + dy, t2),
      new Point(this.x - this.r1 + dx, this.y + this.r1 + dy, t2),
      new Point(this.x + this.r1 + dx, this.y + this.r1 + dy, t2),
    ]
    this.faces = [null, null, null, null, null, null];

  }
  getFaces() {
    var rtrn = [];
    for (var i = 0; i < 6; i++) {
      const pnts = pointsInFaces[i];
      this.faces[i] = this.faces[i] | new Face(pnts[0], pnts[1], pnts[2], pnts[3]);
      rtrn.push(this.faces[i]); // TODO, wanted this to be yields
    }
    return rtrn;
  }

  getIntersection(timeSolid) {
    if (timeSolid.type == "parallelepiped") {
      rejoice();
      // UNDER CONSTRUCTION //

    }
  }
}
export class TimeCylinder extends TimeSolid { // technically it would be a TimeObliqueEllipticCylinder, but... yeah..
  /**
   * @param {Number} x the coordinate of the center of the shape at time t1
   * @param {Number} y the coordinate of the center of the shape at time t1
   * @param {Number} ------------------FIX
   * @param {Number} ------------------FIX
   * @param {Number} t1 the time in millisecods from the start of the game at which this time solid begins
   * @param {Number} t2 the time in millisecods from the start of the game at which this time solid ends
   * @param {Point} vector the vector of movement of this shape through time: (dx, dy, dt).
   */
  constructor(x, y, r1, r2, t1, t2, vector) {
    super("cylinder", x, y, r1, r2, t1, t2, vector);
  }
  getFaces() {
    // idk how to implement this yet
  }
}

function rejoice() {
  console.log("YES!! :)");
}